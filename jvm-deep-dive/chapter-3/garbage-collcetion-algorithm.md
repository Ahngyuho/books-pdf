# 3.3 가비지 컬렉션 알고리즘

마크 스윕
마크 스윕은 회수할 객체를 mark 하고, mark 된 객체를 한번에 쓸어담는 방식

이후에 나올 알고리즘 보다 단순하지만, 두 가지 문제가 존재


1. 메모리 파편화 심함.
   회수할 객체를 표시하고, 그 표시된 것들을 한번에 처리하는 방식이라 회수된 다음에 메모리 공간에 불연속적인 패턴이 발생함.
2. 실행 효율이 일정하지 않음
   객체가 많으면 많을수록 회수하기 위한 mark 작업도 많아지고, 회수작업도 많아진다. 즉 객체가 많을수록 효율이 않 좋다. 근데 이게 왜 안 좋은 건지 모르겠다. 당연한거 아닌가.

마크 컴팩트
이 알고리즘은 마크 스윕처럼, 회수할 객체를 mark 하고, 회수할 때는 메모리 구역 한 쪽에 생존한 객체들을 모아둔 다음에, 나머지 영역을 한꺼번에 비워버린다.

마크 스윕을 할 것인지, 마크 컴팩트를 할것인지...
메모리 파편화를 신경쓸 것인지, 메모리 할당 및 재 연결을 신경쓸 것인지 ...

두 알고리즘의 핵심 차이는 메모리 이동의 유무

메모리 이동은 상당한 비용이 필요.
특히 구세대의 경우는 상당히 많은 객체들이 살아남기 때문에 -> 그만큼 더 많은 이동이 발생함.
메모리가 이동됐기 때문에 이 이동된 객체들을 참조하고 있던 객체들 또한 이 참조값을 갱신해야 하기 때문에 이런 부분에서 비용이 많이듦

그렇다고 해서 메모리 이동을 하지 않으면 메모리 파편화가 심해져서, 메모리 할당이 어려운 상황까지 올 수 있음.
이 문제를 해결하기 위해서 또 어떤 방식을 도입해서 문제를 해결해야 한다.
예를 들어 , 파편화 없는 할당 연결 리스트... -> 이런 시도들이 파편화 문제는 해결하지만, 메모리 할당 및 접근이 더욱 어려워지게 만듦 ㅠㅠ..

메모리를 이동시켜 회수 작업을 복잡하게 할 것인지, 
메모리를 이동시키지 않아 파편화를 발생시키고, 이를 위한 추가 알고리즘을 도입하여 메모리 할당 및 접근을 어렵게 만들 것인지...

선택... 딜레마

해법은 사실 그냥 두개를 같이 쓰는 것이고, 뒤에 나온다고 한다 ^^
