# Concurrency Control (동시성 제어) — 요약 및 해설

> 17장에서 트랜잭션의 핵심 속성 중 하나가 **격리성(Isolation)** 이라고 했습니다. 하지만 여러 트랜잭션이 **동시에** 실행되면 격리성이 깨질 수 있습니다. 이를 방지하기 위해 시스템은 **동시성 제어(Concurrency-Control)** 기법으로 트랜잭션 간 상호작용을 관리합니다.  
> 이 문서는 실패 복구는 제외(19장에서 다룸)하고, **동시에 실행되는 트랜잭션의 관리**와 대표 기법들을 정리합니다. 실무에서 가장 널리 쓰이는 기법은 **2단계 잠금(2PL)** 과 **스냅샷 격리(Snapshot Isolation)** 입니다.

---

## 1) 잠금 기반 프로토콜 (Lock-Based Protocols)

### 1-1. 잠금 모드 (Locks)
데이터 항목 `Q`에 대해 트랜잭션 `Ti`가 요청/보유할 수 있는 대표 모드는 두 가지입니다.

- **S (Shared, 공유)**: 읽기 가능, 쓰기 불가  
- **X (Exclusive, 배타)**: 읽기/쓰기 모두 가능

여러 트랜잭션이 **동시에 읽기(S)** 는 허용되지만, **쓰기(X)** 는 **단독**이어야 합니다.

#### 잠금 호환성(Compatibility)
요청 모드 A, 보유 모드 B의 호환성은 아래와 같습니다.

|      | S     | X     |
|------|-------|-------|
| **S** | true  | false |
| **X** | false | false |

- **S-S** 는 호환(같이 읽기 OK)  
- **S-X**, **X-무엇이든** 은 비호환

#### 잠금/해제 명령
- `lock-S(Q)`: Q에 대한 공유 잠금 요청  
- `lock-X(Q)`: Q에 대한 배타 잠금 요청  
- `unlock(Q)`: Q 잠금 해제

> **주의**: 데이터 항목에 접근(읽기/쓰기)하는 동안에는 **항상** 해당 항목의 잠금을 **보유**해야 합니다. 마지막 접근 직후 곧바로 풀면 **직렬가능성**이 깨질 수 있습니다.

### 1-2. 예시: 은행 송금과 총액 출력

- `T1`: B에서 A로 \$50 이체  
- `T2`: A+B 총액 출력

초기값이 `A=100`, `B=200`이면, 직렬 실행(`T1→T2` 또는 `T2→T1`)은 항상 **300**을 출력합니다.  
하지만 동시 실행에서 `T1`이 **너무 일찍 B의 잠금을 해제**하면, `T2`가 **불일치 상태**를 읽어 **250**을 출력할 수 있습니다.

해결책: **해제 시점을 트랜잭션 끝(커밋)으로 지연**하면, 위와 같은 잘못된 스케줄은 더 이상 발생하지 않습니다(아래 Strict 2PL 참고).

### 1-3. 교착상태(Deadlock)
잠금을 **너무 늦게** 풀면 이번에는 **교착상태**가 발생할 수 있습니다.  
예: `T3`가 `B`에 X를 보유하는 동안 `T4`가 `B`의 S를 요청하여 대기하고, 동시에 `T4`가 `A`에 S를 보유하는 동안 `T3`가 `A`의 X를 요청하여 서로 **서로를 기다리는** 상황이 될 수 있습니다.  
이때 시스템은 **둘 중 하나를 롤백**하여 잠금을 풀고 진행시킵니다.

> **요점**:  
> - **잠금을 쓰지 않거나 너무 일찍 해제** ⇒ **불일치 상태** 위험  
> - **잠금을 너무 늦게 해제** ⇒ **교착** 위험  
> - 현실적으로 교착은 **롤백으로 해결 가능**하므로 감수할 수 있지만, 불일치 상태는 실제 문제를 초래하므로 **더 위험**합니다.

---

## 2) 스케줄·직렬가능성과 잠금 프로토콜

- 트랜잭션 집합 `{T0, …, Tn}`의 스케줄 `S`에서, 항목 `Q`에 대해 `Ti`가 먼저 모드 `A`로 잠그고, 이후 `Tj`가 모드 `B`로 잠갔으며 `comp(A,B)=false` 라면 `Ti → Tj` 라고 합니다.  
- 이 **선행관계 그래프**가 **비순환**이면 **충돌 직렬가능(Conflict-Serializable)** 입니다.  
- **잠금 프로토콜**은 “언제 무엇을 잠그고/푸는가”의 규칙으로, 가능한 스케줄을 제한하여 **충돌 직렬가능성**을 보장합니다.

---

## 3) 잠금 부여(Granting)와 기아(Starvation) 방지

요청이 기존 잠금과 **충돌하지 않으면** 즉시 부여할 수 있습니다. 다만 **기아**를 피하려면:

- 항목 `Q`에 대해 트랜잭션 `Ti`의 모드 `M` 요청은  
  1) 현재 `Q`에 **충돌 모드**가 없어야 하고,  
  2) `Ti`보다 **이전에 도착해 대기 중인 요청이 없어야**  
부여합니다. (**선착순 보장**)

---

## 4) 2단계 잠금 (Two-Phase Locking, 2PL)

**규칙**:
1. **성장 단계**: 잠금 **획득만** 가능 (해제 금지)  
2. **축소 단계**: 잠금 **해제만** 가능 (새 획득 금지)

- 각 트랜잭션의 **마지막 잠금 획득 시점**(Lock Point) 순서가 곧 직렬 순서가 되어 **충돌 직렬가능성**을 보장합니다.
- 단, **교착 회피는 보장하지 않음**.
- 기본 2PL은 **연쇄 롤백(Cascading Rollback)** 이 발생할 수 있습니다.

### 4-1. Strict / Rigorous 2PL

- **Strict 2PL**: **모든 X 잠금**을 **커밋까지 유지**  
  → 미커밋 쓰기 데이터를 타 트랜잭션이 읽지 못해 **연쇄 롤백 방지**

- **Rigorous 2PL**: **모든 잠금(S/X)** 을 **커밋까지 유지**  
  → **커밋 순서**가 곧 **직렬 순서**

### 4-2. 잠금 변환 (Lock Conversion)

동시성을 높이기 위해 **변환**을 허용할 수 있습니다.

- **업그레이드(Upgrade)**: `S → X` (**성장 단계에서만** 허용)  
- **다운그레이드(Downgrade)**: `X → S` (**축소 단계에서만** 허용)

> 예: 대부분 읽기만 하다가 마지막에만 쓰기 필요 시, 처음엔 `S`로 진행하다가 마지막에 `X`로 업그레이드하면 다른 트랜잭션과 **동시성**을 높일 수 있습니다.

### 4-3. 자동 잠금 부여 스키마(간이 구현)

- `read(Q)` 호출 시: `lock-S(Q)` → `read(Q)`  
- `write(Q)` 호출 시: 보유 잠금이 `S`면 `upgrade(Q)` 후 `write(Q)`, 아니면 `lock-X(Q)` 후 `write(Q)`  
- 트랜잭션 **커밋/어보트** 시 보유 잠금 **전부 해제**

---

## 5) 잠금 매니저 구현 (Lock Manager)

**구성요소**:
- **잠금 테이블**(Lock Table): 항목 이름을 키로 해당 항목의 **요청 대기열(연결 리스트)** 관리  
  - 각 요청: (트랜잭션 ID, 모드, 승인 여부)  
  - 항목별로 **도착 순서** 유지(선착순으로 기아 방지)  
- **트랜잭션 인덱스**: 특정 트랜잭션이 보유 중인 잠금 집합 조회용

**동작**:
- **요청 수신**: 리스트 뒤에 추가. 즉시 승인 가능하면 승인, 아니면 대기  
- **해제 수신**: 해당 요청 삭제 후 **다음 대기 요청들**을 순서대로 **승인 가능하면 승인**  
- **어보트**: 대기 요청 제거, 복구 완료 후 보유 잠금 해제

> 이 구조는 **기아 방지**를 보장합니다. (교착 검출/해결은 별도)

---

## 6) 그래프 기반 프로토콜 (Graph-Based Protocols)

2PL이 아닌 프로토콜로도 **충돌 직렬가능**을 만들려면 **추가 정보**(데이터 접근 순서)가 필요합니다.  
데이터 항목 집합 `D = {d1, …, dh}` 에 **부분 순서 `→`** 를 부여하여, `di → dj` 이면 둘 다 접근하는 트랜잭션은 **반드시 `di`를 먼저** 접근해야 한다고 강제합니다. 이렇게 하면 `D`는 DAG(데이터베이스 그래프)가 됩니다.

여기서는 단순화를 위해 **트리 형태**만 다루고, **배타(X) 잠금만** 쓰는 **트리 프로토콜(Tree Protocol)** 을 소개합니다.

### 트리 프로토콜 규칙 (트랜잭션 `Ti`)
1. `Ti`의 **첫 잠금**은 **임의 항목**에서 가능  
2. 이후 항목 `Q`를 잠그려면 **`Q`의 부모를 현재 `Ti`가 잠그고 있어야** 함  
3. **언제든** 잠금 해제 가능  
4. 한 번 **잠그고 해제한 항목**은 **다시 잠글 수 없음**

- 트리 프로토콜을 따르는 **모든 합법 스케줄은 충돌 직렬가능**입니다.
- 또한 **교착이 발생하지 않습니다(Deadlock-Free)**.

> 다만 트리 프로토콜은 기본 형태로는 **회복 가능성/비연쇄성**을 보장하지 않습니다. 이를 보장하려면 X 잠금을 **커밋까지 유지**하거나, **커밋 의존성**(미커밋 데이터 읽기 시, 해당 작성자 트랜잭션이 커밋될 때까지 독자 트랜잭션 커밋 금지)을 관리하는 방식을 사용할 수 있습니다.

### 장단점 요약
- **장점**: 교착 없음, 잠금을 더 **일찍 해제**할 수 있어 동시성 향상 가능  
- **단점**: 실제로 접근하지 않을 **경로상의 노드까지 잠가야** 할 수 있어 오버헤드/대기 증가, 사전 접근 경로 지식이 없으면 루트부터 잠가야 해서 동시성 저하

> 2PL로 가능한 어떤 스케줄은 트리 프로토콜로는 불가능하고, 그 **반대**도 존재합니다.

---

## 참고: 용어 정리

- **충돌 직렬가능(Conflict-Serializable)**: 충돌(비호환) 연산 순서를 보존하는 직렬 스케줄과 동등  
- **연쇄 롤백(Cascading Rollback)**: 미커밋 데이터를 읽은 트랜잭션들이 도미노처럼 되돌려지는 현상  
- **Strict 2PL**: 모든 **X 잠금**을 커밋까지 유지(연쇄 롤백 방지)  
- **Rigorous 2PL**: 모든 **S/X 잠금**을 커밋까지 유지(커밋 순서=직렬 순서)  
- **기아(Starvation)**: 어떤 요청이 계속 뒤로 밀려 영원히 처리되지 않는 상태  
- **교착(Deadlock)**: 서로가 서로의 자원을 기다려 아무도 진행하지 못하는 상태

---

## 빠른 요약(핵심만)

- **S/X 잠금**, 호환성 표로 충돌 판단  
- **2PL**: 성장 단계(획득만) → 축소 단계(해제만) ⇒ **충돌 직렬가능 보장**  
- **Strict/Rigorous 2PL**: **연쇄 롤백 방지**, **커밋 순서 직렬화**  
- **잠금 변환(업/다운그레이드)** 으로 동시성 향상  
- **잠금 매니저**: 항목별 대기열 + 선착순으로 **기아 방지**  
- **트리 프로토콜**: **교착 없음**, 경로 잠금 필요(오버헤드 가능)

---

# Deadlock Handling (교착상태 처리)

시스템이 **교착상태(deadlock)** 에 빠졌다는 것은, 어떤 트랜잭션 집합이 존재하여 그 집합에 속한 **모든 트랜잭션이 서로 집합 안의 다른 트랜잭션을 기다리고 있음**을 의미합니다.  
좀 더 정확히 말하면, **대기 중인 트랜잭션 집합** `{T0, T1, …, Tn}` 이 존재하여:

- `T0` 는 `T1` 이 보유한 데이터 항목을 기다리고,
- `T1` 은 `T2` 가 보유한 데이터 항목을 기다리고,
- …
- `Tn−1` 은 `Tn` 이 보유한 데이터 항목을 기다리며,
- `Tn` 은 `T0` 가 보유한 데이터 항목을 기다립니다.

이러한 상황에서는 어떤 트랜잭션도 **진행할 수 없습니다**.

---

## 교착상태 발생 시 조치

이 바람직하지 않은 상황을 해소하기 위해 시스템은 **급진적인 조치(drastic action)** 를 취해야 하며, 보통 **교착상태에 연루된 일부 트랜잭션을 롤백**합니다.

- **부분 롤백(Partial Rollback)**: 트랜잭션 전체를 되돌리는 대신, **교착 해소에 필요한 특정 락을 획득하기 전 지점**까지 되돌립니다. 해당 락을 **해제**함으로써 교착을 해소할 수 있습니다.

---

## 교착상태 대응 방법(두 가지 원칙)

1. **교착상태 예방(Deadlock Prevention)**
   - 시스템이 **교착상태에 절대 진입하지 않도록** 하는 프로토콜을 사용합니다.

2. **교착상태 탐지 및 복구(Deadlock Detection & Recovery)**
   - 교착상태에 **진입을 허용**한 뒤, **탐지 알고리즘**으로 교착을 발견하고 **복구 절차**(예: 롤백)로 해소합니다.

> 두 방법 모두 상황에 따라 **트랜잭션 롤백**이 발생할 수 있습니다.

---

## 선택 가이드

- 시스템이 **교착상태에 빠질 확률이 비교적 높다면** → **예방(Prevention)** 이 일반적으로 선호됩니다.
- 그 외의 경우 → **탐지 및 복구(Detection & Recovery)** 가 **더 효율적**인 경향이 있습니다.

---

## 탐지·복구 방식의 오버헤드

탐지 및 복구 방식은 다음과 같은 **추가 비용**을 수반합니다.

- **런타임 비용**: 필요한 정보를 유지하고 **탐지 알고리즘을 실행**하는 비용
- **잠재적 손실**: 교착상태에서 **복구(예: 롤백)** 과정에서 발생할 수 있는 **성능 저하 및 작업 손실**

---

# 18.2.1 Deadlock Prevention (교착상태 예방)

교착상태 예방에는 **두 가지 접근**이 있습니다.

1) **순환 대기(cyclic wait) 자체를 불가능하게** 만드는 방식  
   - 락 요청에 **순서(ordering)** 를 부여하거나, **모든 락을 한꺼번에** 획득하도록 강제

2) **잠재적 교착 상황에서 기다리지 않고 즉시 롤백**하는 방식  
   - 교착이 **될 수도 있는 대기**라면 **기다림 대신 롤백**을 수행

---

## 1. “순환 대기 불가” 방식

### 1.1 모든 데이터 항목을 실행 전 **일괄 락**(all-or-nothing)
- 각 트랜잭션이 **시작 전에 필요 데이터 전부를 락**으로 잡고,  
  **전부를 한 번에** 잠그거나 **아예 하나도 잠그지 않음**.
- **단점**
  1. 트랜잭션 시작 전에 **무슨 항목을 락해야 하는지 예측**하기 어렵다.
  2. **자원 활용도 저하**: 오래 쓰지 않을 항목까지 **오랫동안 불필요하게 락**.

### 1.2 데이터 항목에 **순서(order)** 를 부여해 **그 순서대로만 락** 요청
- 예: **트리 프로토콜(Tree Protocol)** — 데이터 항목에 **부분 순서(partial order)** 부여
- 변형: **총순서(total order)** + **2단계 잠금(2PL)**  
  - 한 항목을 락으로 잡은 뒤에는, **그보다 앞서는 항목**에 대해 **새로운 락을 요청할 수 없음**.
  - 구현이 간단(트랜잭션이 접근할 항목 집합이 **사전에 알려진 경우**).
  - **기존 2PL 엔진을 바꾸지 않고**, **락 요청 순서만 보장**하면 됨.

---

## 2. “대기 대신 롤백” 방식 (선점/타임스탬프 기반)

**선점(preemption)**: `Tj`가 `Ti`가 보유한 락을 요청했을 때,  
`Ti`를 **롤백**시켜 락을 **Tj**에게 주는 것.

- 각 트랜잭션 시작 시 **고유 타임스탬프**(카운터/시계 기반)를 부여
- 이 타임스탬프는 **기다릴지 롤백할지** 결정을 위해서만 사용(락은 여전히 사용)
- **롤백 후 재시작**할 때는 **기존 타임스탬프 유지**

타임스탬프를 이용한 대표 **교착 예방** 기법 두 가지:

### 2.1 **Wait–Die** (비선점적, Nonpreemptive)
- `Ti`가 `Tj`가 보유한 항목을 요청할 때,
  - `TS(Ti) < TS(Tj)` (즉, **Ti가 더 오래됨**) 이면 **기다릴 수 있음**.
  - 그렇지 않으면 **Ti가 롤백(Die)**.
- 예: `T14(5), T15(10), T16(15)`  
  - `T14` → `T15`의 항목 요청 ⇒ **T14 기다림**  
  - `T16` → `T15`의 항목 요청 ⇒ **T16 롤백**

### 2.2 **Wound–Wait** (선점적, Preemptive)
- `Ti`가 `Tj`가 보유한 항목을 요청할 때,
  - `TS(Ti) < TS(Tj)` (즉, **Ti가 더 오래됨**) 이면 **Tj를 롤백**(Ti가 **상처(wound)** 를 입힘).  
  - 그렇지 않으면 **Ti가 기다림**.
- 예: `T14(5), T15(10), T16(15)`  
  - `T14` → `T15`의 항목 요청 ⇒ **T15 롤백**(선점)  
  - `T16` → `T15`의 항목 요청 ⇒ **T16 기다림**

> 두 방식 모두 **불필요한 롤백**이 발생할 수 있다는 **단점**이 있음.

---

## 3. **락 타임아웃 기반** 예방

- 락을 요청한 트랜잭션이 **최대 대기 시간**까지만 기다림.
- 그 시간 내 락을 못 얻으면 **타임아웃**으로 **자기 자신을 롤백 후 재시작**.
- 실제로 교착이 있었다면, 관련 트랜잭션 중 하나 이상이 타임아웃으로 **롤백되어** 다른 트랜잭션이 진행 가능.
- 성격: **완전한 예방**(교착이 절대 발생하지 않음)과 **탐지·복구**(발생 후 처리)의 **중간 어딘가**.
- **장점**: 구현이 **매우 간단**, **짧은 트랜잭션** & **오랜 대기=교착일 가능성 높음**인 환경에서 효과적.
- **어려움/주의**
  - **얼마나 기다려야 하는가**를 정하기 어려움.
    - 너무 길면: 교착 발생 후에도 **불필요한 지연**.
    - 너무 짧으면: **교착이 아닌데도 롤백**(자원 낭비).
  - **기아(Starvation)** 가능성.
  - 따라서 **적용 범위가 제한적**.

---

## 요약

- **순환 대기 차단**: 일괄 락, **(부분/총)순서 부여 + 2PL**  
- **대기 대신 롤백**: **Wait–Die / Wound–Wait** (타임스탬프 기반)  
- **타임아웃**: 간단하지만 **튜닝 난이도/기아 위험** → 환경에 따라 제한적  
- 모든 방법은 **성능·불필요 롤백·개발/운영 복잡도** 사이에서 **트레이드오프**가 있음.

---

# 18.2.2 Deadlock Detection and Recovery (교착상태 탐지와 복구)

교착상태가 절대 발생하지 않도록 보장하는 프로토콜을 사용하지 않는 시스템이라면, **탐지와 복구** 체계를 사용해야 합니다. 시스템 상태를 주기적으로 점검하여 **교착이 발생했는지** 확인하는 **탐지 알고리즘**을 호출합니다. 교착이 발견되면 **복구**를 시도해야 합니다. 이를 위해 시스템은 다음을 수행해야 합니다.

- 현재 **데이터 항목의 할당 정보**와 **대기 중인(미충족) 요청 정보**를 유지한다.
- 이 정보를 사용해 **교착 상태 진입 여부를 판정**하는 알고리즘을 제공한다.
- 탐지 알고리즘이 교착을 발견하면 **교착을 해소**(복구)한다.

아래에서 세부 사항을 설명합니다.

---

## 18.2.2.1 Deadlock Detection (교착상태 탐지)

교착상태는 **Wait-For Graph(대기 그래프)** 라는 방향 그래프로 정확히 표현할 수 있습니다.  
그래프는 쌍 \( G = (V, E) \) 로, \( V \) 는 정점 집합(시스템의 모든 트랜잭션), \( E \) 는 간선 집합입니다.  
각 간선은 **정렬쌍** \( T_i \rightarrow T_j \) 로 표시되며, 이는 **트랜잭션 \(T_i\) 가 \(T_j\)** 가 보유한 **필요 데이터 항목의 해제**를 기다리고 있음을 의미합니다.

- \(T_i\) 가 \(T_j\) 가 쥐고 있는 데이터 항목을 요청하면 **간선 \(T_i \rightarrow T_j\)** 를 그래프에 **삽입**합니다.
- \(T_j\) 가 더 이상 \(T_i\) 가 필요로 하는 항목을 보유하지 않게 되면 해당 **간선을 제거**합니다.
- **교착상태가 존재할 필요충분조건**: **대기 그래프에 사이클이 존재**한다.
- 탐지를 위해 시스템은 **대기 그래프를 유지**하고, **주기적으로 사이클 탐색** 알고리즘을 실행합니다.

### 예시 (그림 18.13)
- \(T_{17}\) 은 \(T_{18}\), \(T_{19}\) 를 기다림
- \(T_{19}\) 는 \(T_{18}\) 을 기다림
- \(T_{18}\) 은 \(T_{20}\) 을 기다림

이때 **사이클이 없으므로 교착상태가 아님**.

이후 \(T_{20}\) 이 \(T_{19}\) 가 보유한 항목을 요청하면 간선 \(T_{20} \rightarrow T_{19}\) 가 추가되어 **그림 18.14** 와 같은 상태가 되고, 다음 **사이클**이 생깁니다:

\[
T_{18} \rightarrow T_{20} \rightarrow T_{19} \rightarrow T_{18}
\]

따라서 \(T_{18}, T_{19}, T_{20}\) 은 **모두 교착** 상태입니다.

### 탐지 알고리즘을 언제 호출할 것인가?
다음 요소에 따라 결정합니다.

1. **교착 발생 빈도**가 얼마나 높은가?
2. 교착으로 인해 **영향을 받는 트랜잭션 수**가 얼마나 되는가?

- 교착이 **자주 발생**한다면, 탐지 알고리즘을 **더 자주 호출**해야 합니다.
- 교착에 묶인 데이터 항목은 **교착이 해소될 때까지** 다른 트랜잭션이 사용할 수 없습니다.
- 대기 그래프의 **사이클 수가 증가**할 수 있으므로, **최악의 경우**에는 **할당 요청이 즉시 처리되지 못할 때마다** 탐지 알고리즘을 호출할 수도 있습니다.

---

## 18.2.2.2 Recovery from Deadlock (교착상태 복구)

탐지 알고리즘이 교착을 발견하면, 시스템은 **교착을 해소**해야 합니다. 가장 일반적인 방법은 **하나 이상의 트랜잭션을 롤백**하여 사이클을 **끊는 것**입니다. 필요한 조치는 다음과 같습니다.

### 1) 희생자(victim) 선택
- 교착에 연루된 트랜잭션 중 **어느 것을 롤백할지** 결정합니다.
- 이상적으로는 **비용이 최소**가 되도록 선택해야 하나, **“최소 비용”의 정의는 모호**할 수 있습니다.
- **비용 판단 요소 예시**:
  - (a) 트랜잭션이 이미 **얼마나 오래 수행**했으며, 완료까지 **얼마나 더** 수행해야 하는가
  - (b) 트랜잭션이 **사용한 데이터 항목 수**
  - (c) 트랜잭션이 **추가로 필요**로 하는 데이터 항목 수
  - (d) 롤백에 **연루될 트랜잭션 수**

### 2) 롤백(rollback)
- 특정 트랜잭션을 롤백하기로 했다면, **어느 지점까지** 롤백할지 결정해야 합니다.
- 가장 단순한 방법은 **총 롤백(total rollback)**: **Abort 후 재시작**.
- 더 효과적인 방법은 **교착을 깨는 데 필요한 최소 지점까지만 부분 롤백**하는 것입니다.
  - 이를 위해 시스템은 실행 중인 모든 트랜잭션에 대한 **추가 상태 정보**를 유지해야 합니다.
  - 특히, **락 요청/부여의 순서**와 **수행된 갱신**을 기록해야 합니다.
  - **교착 탐지 메커니즘**은 **어떤 락을 해제**해야 교착이 깨지는지 결정해야 합니다.
  - 선택된 트랜잭션은 이 **락들을 최초로 획득한 시점까지 되돌아가고**, 그 이후의 모든 작업을 **되돌려야** 합니다.
  - 복구 메커니즘은 이러한 **부분 롤백**을 수행할 수 있어야 하며, 롤백 후 트랜잭션은 **다시 실행 재개**가 가능해야 합니다.

### 3) 기아(starvation) 방지
- 비용 위주로 희생자를 고르면 **같은 트랜잭션이 반복해서 희생**되는 일이 생길 수 있습니다.
- 이 경우 해당 트랜잭션은 **영원히 완료되지 못하는 기아**가 발생합니다.
- 대책: **롤백 횟수**를 비용 요소에 포함하는 등, **동일 트랜잭션이 희생자로 선택되는 횟수에 제한**을 둡니다.

---
# 18.3 Multiple Granularity (다중 그레뉴러리티)

지금까지 소개한 동시성 제어 기법들은 **각 개별 데이터 항목**을 동기화 단위로 사용했습니다.  
그러나 경우에 따라 여러 데이터 항목을 **그룹으로 묶어 하나의 동기화 단위**처럼 다루는 것이 유리할 때가 있습니다.

예를 들어, 트랜잭션 `Ti` 가 **전체 릴레이션**에 접근해야 하는데 잠금 프로토콜이 **튜플 단위**로만 잠금을 잡는다면, `Ti` 는 릴레이션의 **모든 튜플**을 각각 잠가야 합니다. 이는
- 잠금 획득에 **시간이 많이 들고**,
- 잠금 테이블이 **매우 커져 메모리에 맞지 않을 수도** 있습니다.

이럴 때 `Ti` 가 **릴레이션 전체를 한 번의 잠금 요청**으로 잠글 수 있다면 더 낫습니다. 반대로, `Tj` 가 **소수의 튜플**만 접근한다면 **릴레이션 전체**를 잠그도록 강제해 **병행성**을 잃어서는 안 됩니다.

---

## 다중 그레뉴러리티의 개념

필요한 것은 시스템이 **여러 수준의 그레뉴러리티(단위 크기)** 를 정의할 수 있는 메커니즘입니다.

- 데이터 항목을 여러 크기로 정의하고, **작은 단위가 큰 단위 안에 포함되는 계층**을 만듭니다.
- 이 계층은 **트리**로 표현할 수 있습니다(※ 여기의 트리는 18.1.5절의 *트리 프로토콜*에서 쓰는 트리와 의미가 다릅니다).
  - **다중 그레뉴러리티 트리**에서 **내부 노드**는 자신의 **모든 하위 노드(후손)** 가 나타내는 데이터를 **포함**합니다.
  - (트리 프로토콜에서 각 노드는 **독립적인 데이터 항목**임)

### 예시 트리(4계층)

- 최상위: **데이터베이스(DB)**
- 그 아래: **영역(area)** — DB는 여러 영역으로 구성
- 각 영역 아래: **파일(file)**
- 각 파일 아래: **레코드(record)**

각 **노드**는 **개별적으로 잠글 수** 있습니다. 2단계 잠금(2PL)과 마찬가지로 **공유(S)** / **배타(X)** 모드를 사용합니다.

- 어떤 트랜잭션이 **노드 하나**를 S 또는 X로 잠그면, 그 **하위 모든 노드**도 **암묵적으로 같은 모드로 잠금**됩니다.
  - 예: `Ti` 가 파일 `Fc` 를 **X-락**으로 명시적 잠금 ⇒ `Fc` 의 **모든 레코드**를 **암묵적으로 X-락**한 것과 같음(레코드별로 따로 잠글 필요 없음)

---

## 경로 검사와 의도 잠금(Intention Lock)

- `Tj` 가 파일 `Fb` 의 레코드 `rb6` 를 잠그고 싶다고 합시다. 만약 누군가(`Ti`)가 **파일 `Fb` 자체**를 잠갔다면, `rb6` 는 **암묵적으로 잠겨 있음**입니다.
- `Tj` 가 `rb6` 에 대한 **명시적 잠금 요청**을 하면, 시스템은 **루트에서 `rb6` 까지의 경로**를 따라 올라가며 **비호환 잠금**이 있는지 확인합니다. 경로 상 **어느 노드라도 비호환 모드**로 잠겨 있으면 `Tj` 는 **대기**해야 합니다.

이제 `Tk` 가 **DB 전체**를 잠그려 한다고 합시다. 이는 **루트 노드**를 잠그면 됩니다. 하지만 누군가가 **부분 트리(예: 파일 `Fb`)** 를 이미 잠갔다면, `Tk` 는 루트를 잠글 수 없어야 합니다. 이를 알아내기 위해 **전체 트리를 스캔**하는 것은 비효율적입니다.

그래서 **의도 잠금(Intention Lock)** 이 도입됩니다.

- **의도 잠금**이 걸린 노드는, **더 낮은 수준**(더 **미세한 단위**)에서 **명시적 잠금**이 이루어지고 있음을 알리는 **신호**입니다.
- 어떤 노드를 명시적으로 잠그기 전에, **그 노드의 모든 조상 노드**에 **의도 잠금**을 겁니다.
- 트랜잭션이 특정 노드 `Q` 를 잠그고 싶으면, **루트 → `Q` 경로**를 따라 내려오면서 **의도 잠금**을 설정합니다.

### 의도 잠금의 종류

- **IS (Intention-Shared)**: 아래 레벨에서 **공유(S)** 잠금들을 걸겠다는 의도
- **IX (Intention-Exclusive)**: 아래 레벨에서 **배타(X) 또는 공유(S)** 잠금들을 걸겠다는 의도
- **SIX (Shared + Intention-Exclusive)**: 해당 노드의 **서브트리 전체를 S로 잠근 것**과 같고, **아래 레벨에서 X 잠금**도 추가로 걸겠다는 의도

### 호환성(Compatibility) 매트릭스

| 요청\보유 | IS | IX | S | SIX | X |
|:--:|:--:|:--:|:--:|:--:|:--:|
| **IS**  | ✔ | ✔ | ✔ | ✔ | ✖ |
| **IX**  | ✔ | ✔ | ✖ | ✖ | ✖ |
| **S**   | ✔ | ✖ | ✔ | ✖ | ✖ |
| **SIX** | ✔ | ✖ | ✖ | ✖ | ✖ |
| **X**   | ✖ | ✖ | ✖ | ✖ | ✖ |

---

## 다중 그레뉴러리티 잠금 프로토콜(규칙)

트랜잭션 `Ti` 가 노드 `Q` 를 잠그려 할 때 다음을 **모두** 만족해야 합니다.

1. **호환성 표**(위 표)를 **준수**한다.
2. **루트부터 먼저** 잠근다(모드는 제한 없음).
3. `Q` 를 **S 또는 IS** 로 잠그려면, **부모 노드**에 **IX 또는 IS** 가 **이미** 잠겨 있어야 한다.
4. `Q` 를 **X, SIX, IX** 로 잠그려면, **부모 노드**에 **IX 또는 SIX** 가 **이미** 잠겨 있어야 한다.
5. **잠금 해제 이전에 새 잠금 금지**(즉, **2단계(2PL)** 규칙 준수).
6. `Q` 의 **자식들 중 어떤 것도 잠겨 있지 않을 때만** `Q` 를 **해제**할 수 있다.

> 요약: **획득은 위에서 아래(Top-Down)**, **해제는 아래에서 위(Bottom-Up)**  
> 교착 상태는 2PL과 마찬가지로 **가능**합니다.

---

## 프로토콜 동작 예시

앞선 4계층 트리( DB → Area → File → Record )에서:

- **`T21` 이 파일 `Fa` 의 레코드 `ra2` 를 읽기**  
  1) DB, 2) `A1`, 3) `Fa` 를 **IS** 모드로(이 순서) 잠근 뒤,  
  4) `ra2` 를 **S** 모드로 잠금.

- **`T22` 가 파일 `Fa` 의 레코드 `ra9` 를 수정**  
  1) DB, 2) `A1`, 3) `Fa` 를 **IX** 모드로(이 순서) 잠근 뒤,  
  4) `ra9` 를 **X** 모드로 잠금.

- **`T23` 이 파일 `Fa` 의 모든 레코드를 읽기(파일 전체 읽기)**  
  1) DB, 2) `A1` 을 **IS** 모드로(이 순서) 잠근 뒤,  
  3) `Fa` 를 **S** 모드로 잠금.

- **`T24` 가 데이터베이스 전체를 읽기**  
  - DB(루트)를 **S** 모드로 잠그면 가능.

**동시성**:
- `T21`, `T23`, `T24` 는 **동시에 접근** 가능.
- `T22` 는 `T21` 과는 **동시** 실행 가능하지만, `T23`/`T24` 와는 **동시 실행 불가**.

> 이 프로토콜은 **병행성 향상**과 **잠금 오버헤드 감소**에 도움을 줍니다.  
> 특히 다음과 같은 혼합 워크로드에서 유용합니다.
> - **짧은 트랜잭션**: 소수의 데이터 항목만 접근  
> - **긴 트랜잭션**: 전체 파일/파일 집합을 스캔하여 리포트를 생성

---

## 실무: 잠금 수 추정과 에스컬레이션

- SQL 쿼리가 획득할 잠금 수는 대개 **스캔 종류**로 가늠할 수 있습니다.
  - **릴레이션 스캔**: **릴레이션 수준** 잠금
  - **인덱스 스캔(소수 레코드 예상)**: **릴레이션 수준 IS(의도 잠금)** + **튜플 수준** 일반 잠금
- 트랜잭션이 **많은 튜플 잠금**을 획득하면 **잠금 테이블이 포화**될 수 있습니다.  
  이때 **잠금 에스컬레이션(lock escalation)** 을 수행하여, **많은 하위 수준 잠금**을 **상위 수준 잠금 하나**로 **대체**합니다.  
  - 예: **다수의 튜플 잠금** → **한 개의 릴레이션 잠금**으로 승격

---

# 18.4 Insert Operations, Delete Operations, and Predicate Reads  
(삽입/삭제 연산과 프레디킷 읽기)

지금까지는 **read/write** 연산만 다뤘습니다. 이 제한은 트랜잭션을 **이미 DB에 존재하는 데이터 항목**으로 한정합니다. 그러나 어떤 트랜잭션은 **새 데이터 항목 생성(insert)** 이나 **데이터 항목 삭제(delete)** 도 필요합니다. 이러한 연산이 동시성 제어에 미치는 영향을 보기 위해 다음 **추가 연산**을 도입합니다.

- `delete(Q)`: 데이터 항목 `Q` 를 데이터베이스에서 **삭제**한다.  
- `insert(Q)`: **새 데이터 항목** `Q` 를 데이터베이스에 **삽입**하고 초기값을 부여한다.

주의:

- `delete(Q)` **이후**에 어떤 트랜잭션 `Ti` 가 `read(Q)` 를 시도하면, `Ti` 에 **논리 오류**가 발생한다.  
- `insert(Q)` **이전**에 `Ti` 가 `read(Q)` 를 시도해도 **논리 오류**가 발생한다.  
- **존재하지 않는** 데이터 항목을 삭제하려는 시도 역시 **논리 오류**다.

---

## 18.4.1 Deletion (삭제)

삭제 명령이 동시성 제어에 미치는 영향을 이해하려면, **어떤 연산과 충돌하는지**를 정해야 합니다.  
스케줄 `S` 에서 트랜잭션 `Ti`, `Tj` 의 **연속된 두 명령**을 각각 `Ii`, `Ij` 라 하자. 또한 `Ii = delete(Q)` 라 하자. 다음 경우들을 고려합니다.

- `Ij = read(Q)`  
  - `Ii` 와 `Ij` **충돌**.  
  - `Ii` → `Ij` 이면: `Tj` 는 **논리 오류**(삭제된 `Q` 를 읽음).  
  - `Ij` → `Ii` 이면: `Tj` 는 **정상적으로 읽기** 수행 가능.

- `Ij = write(Q)`  
  - `Ii` 와 `Ij` **충돌**.  
  - `Ii` → `Ij` 이면: `Tj` 는 **논리 오류**.  
  - `Ij` → `Ii` 이면: `Tj` 는 **정상적으로 쓰기** 수행 가능.

- `Ij = delete(Q)`  
  - `Ii` 와 `Ij` **충돌**.  
  - `Ii` → `Ij` 이면: `Tj` 는 **논리 오류**(이미 삭제된 `Q` 재삭제).  
  - `Ij` → `Ii` 이면: `Ti` 는 **논리 오류**.

- `Ij = insert(Q)`  
  - `Ii` 와 `Ij` **충돌**.  
  - **사전 상태**에 따라:
    - `Q` 가 **원래 존재하지 않았던** 경우:  
      - `Ii(=delete)` → `Ij(=insert)` 이면: `Ti` **논리 오류** (존재하지 않는 것을 삭제 시도).  
      - `Ij` → `Ii` 이면: **논리 오류 없음**.
    - `Q` 가 **원래 존재했던** 경우:  
      - `Ij(=insert)` → `Ii(=delete)` 이면: **논리 오류** (`Q` 가 있는데 다시 삽입).  
      - 그 외 순서에서는 **논리 오류 없음**.

### 결론 요약

- **2단계 잠금(2PL)**:  
  - 항목을 삭제하려면 해당 항목에 대해 **배타(X) 락**이 **필수**.

- **타임스탬프 순서(TO)**:  
  - 쓰기와 유사한 **검사**가 필요. `Ti` 가 `delete(Q)` 를 발행했다고 하자.  
    - `TS(Ti) < R-timestamp(Q)` 이면: `TS(Tj) > TS(Ti)` 인 어떤 `Tj` 가 이미 `Q` 를 읽음.  
      → 이 **삭제를 거부**하고 `Ti` **롤백**.  
    - `TS(Ti) < W-timestamp(Q)` 이면: `TS(Tj) > TS(Ti)` 인 어떤 `Tj` 가 이미 `Q` 를 **썼음**.  
      → 이 **삭제를 거부**하고 `Ti` **롤백**.  
    - **그 외**: 삭제 **허용**.

---

# 18.4.2 Insertion (삽입)

`insert(Q)` 연산은 `delete(Q)` 와 **충돌**합니다. 마찬가지로 `insert(Q)` 는 `read(Q)` 또는 `write(Q)` 와도 **충돌**합니다. (존재하기 **전**의 데이터 항목에 대해서는 읽기/쓰기를 수행할 수 없음)

`insert(Q)` 는 데이터 항목 `Q` 에 **값을 부여**한다는 점에서, 동시성 제어 측면에서 **쓰기(write)** 와 유사하게 다룹니다.

- **2단계 잠금(2PL)**  
  트랜잭션 `Ti` 가 `insert(Q)` 를 수행하면, 새로 생성된 데이터 항목 `Q` 에 대해 **배타(X) 락**이 부여됩니다.

- **타임스탬프 순서(TO)**  
  트랜잭션 `Ti` 가 `insert(Q)` 를 수행하면, `R-timestamp(Q)` 와 `W-timestamp(Q)` 값을 **`TS(Ti)` 로 설정**합니다.

---
# 18.4.3 Predicate Reads and The Phantom Phenomenon  
(프레디킷 읽기와 팬텀 현상)

두 번째 경우는 흥미롭습니다. **T30**과 **T31**은 공통으로 접근한 튜플이 전혀 없는데도 **서로 충돌**합니다! 실제로 T30과 T31은 **팬텀(phantom) 튜플**에 대해 충돌하는 것입니다. 만약 동시성 제어를 **튜플 단위**에서만 수행한다면, 이러한 충돌은 **탐지되지 않을 수** 있습니다. 그 결과, 시스템은 **비직렬가능 스케줄**을 막지 못할 수 있습니다. 이 문제가 바로 **팬텀 현상**의 한 예입니다.

팬텀 현상은 **삽입(insert)** 에서만이 아니라 **갱신(update)** 에서도 발생할 수 있습니다. 17.10절에서 본 상황처럼, 어떤 트랜잭션 **Ti** 가 인덱스를 사용하여 `dept_name = "Physics"` 인 튜플만 찾고 다른 부서의 튜플은 읽지 않았다고 합시다. 이때 다른 트랜잭션 **Tj** 가 어떤 튜플의 부서를 **Physics로 변경**하면, 위에서 설명한 것과 유사한 문제가 발생합니다. 즉, **Ti** 와 **Tj** 가 공통 튜플에 접근하지 않았더라도 **충돌**이 생깁니다. 이 역시 **팬텀 현상**입니다. 일반적으로 팬텀 현상은 **프레디킷 읽기(predicate read)** 가, 해당 프레디킷을 만족하도록 만드는 **삽입/갱신**과 충돌할 때 발생합니다.

이러한 문제를 방지하려면, 트랜잭션 **T30**이 `instructor` 릴레이션에서 `dept_name = "Physics"` 인 **새 튜플 생성**을 다른 트랜잭션이 하지 못하게 하고, 기존 튜플의 부서를 **Physics로 갱신**하는 것도 **막을 수 있어야** 합니다.  
`dept_name = "Physics"` 인 모든 튜플을 찾기 위해 **T30**은 **릴레이션 전체**를 탐색하거나 적어도 해당 **인덱스**를 탐색해야 합니다. 지금까지는 트랜잭션이 **튜플**만 접근한다고 묵시적으로 가정했지만, **T30**은 “릴레이션에 어떤 튜플들이 존재하는가”라는 **정보를 읽는** 예이고, **T31**은 그 정보를 **갱신하는** 예입니다.

따라서 **접근한 튜플만** 잠그는 것으로는 충분하지 않습니다. **튜플을 찾기 위해 사용된 정보** 또한 잠가야 합니다. 이를 위해 **릴레이션에 대응하는 데이터 항목**(해당 릴레이션의 **튜플 집합을 찾는 데 사용되는 정보**를 대표)을 두어 잠금을 적용할 수 있습니다.

- `T30`처럼 **어떤 튜플들이 존재하는지**에 대한 정보를 **읽는 트랜잭션**은, 해당 **데이터 항목을 공유(S)** 모드로 잠급니다.
- `T31`처럼 그 정보를 **갱신하는 트랜잭션**은, 해당 **데이터 항목을 배타(X)** 모드로 잠급니다.  
  → 이렇게 하면 **T30**과 **T31**은 팬텀이 아닌 **실제 데이터 항목**에서 **충돌**합니다.
- **인덱스를 사용해 튜플을 가져오는 트랜잭션**은 **인덱스 자체**도 잠가야 합니다.

> **주의(다중 그레뉴러리티 잠금과의 차이)**  
> 여기서 말하는 “릴레이션에 **대응하는 데이터 항목**”을 잠그는 것은, 다중 그레뉴러리티에서의 “**릴레이션 전체 잠금**”과 **다릅니다**.  
> 데이터 항목 잠금은 **릴레이션의 튜플 구성 정보 갱신**만 막습니다. **튜플 자체 잠금은 여전히 필요**합니다.  
> 예를 들어, 어떤 트랜잭션이 릴레이션 대응 데이터 항목에 **X-락**을 가지고 있어도, **다른 트랜잭션이 특정 튜플을 직접 접근**하려면 해당 **튜플 락을 부여**할 수 있습니다.

그러나 릴레이션에 대응하는 데이터 항목 전체, 또는 **인덱스 전체**를 잠그면 **동시성 수준이 낮아지는 단점**이 있습니다. 예컨대 **서로 다른 튜플을 삽입**하는 두 트랜잭션도 **동시에 실행**할 수 없게 됩니다.

---

## 인덱스 잠금(Index-Locking)으로 팬텀 줄이기

더 나은 방법은 **인덱스 잠금 기법**으로, 인덱스 전체를 잠그지 않으면서 팬텀을 방지하는 것입니다. 어떤 트랜잭션이 튜플을 **삽입**하면, 해당 릴레이션에 유지되는 **모든 인덱스**에도 정보를 삽입해야 합니다. 이를 이용해 팬텀 현상을 **인덱스 리프(leaf) 노드 잠금 충돌**로 전환합니다. (설명 단순화를 위해 **B+-트리 인덱스**만 고려합니다.)

- 14장에서 보았듯, 각 **검색 키 값**은 **인덱스 리프 노드**에 대응됩니다.
- 일반적으로 쿼리는 하나 이상의 인덱스를 사용해 릴레이션에 접근합니다.
- **삽입 연산**은 해당 릴레이션의 **모든 인덱스**에 새 튜플 정보를 반영해야 합니다.  
  예를 들어, `instructor(dept_name)` 인덱스가 있다고 하면, **T31**은 키 **"Physics"** 를 담은 **리프 노드**를 수정해야 합니다. **T30**이 물리학과 튜플들을 찾기 위해 같은 리프 노드를 **읽는다면**, 두 트랜잭션은 그 **리프 노드에서 충돌**합니다.

### 인덱스 잠금 프로토콜

- **모든 릴레이션은 최소 하나의 인덱스를 가져야 합니다.**
- 트랜잭션 **Ti** 는 **먼저 인덱스를 통해 찾은 후에만** 릴레이션의 튜플에 접근할 수 있습니다.  
  (프로토콜 관점에서 **릴레이션 스캔**은 인덱스의 **모든 리프 노드**를 스캔하는 것으로 간주합니다.)
- **조회(범위 조회/포인트 조회)** 를 수행하는 **Ti** 는 접근하는 **모든 인덱스 리프 노드에 대해 공유(S) 락**을 획득해야 합니다.
- **삽입/삭제/갱신**을 수행하는 **Ti** 는 릴레이션 **r**의 **모든 인덱스**를 갱신해야 하며, **영향받는 모든 인덱스 리프 노드에 대해 배타(X) 락**을 획득해야 합니다.  
  - **삽입/삭제**: (삽입 **후**) 해당 **검색 키 값을 포함**하는 리프, (삭제 **전**) 포함하던 리프  
  - **갱신**: (변경 **전**) **이전 검색 키 값**을 담던 리프 **및** (변경 **후**) **새 검색 키 값**을 담게 될 리프
- **튜플 락**은 기존 방식대로 획득합니다.
- **2단계 잠금(2PL)** 규칙을 준수합니다.

> 인덱스 잠금 프로토콜은 **내부 노드**에 대한 동시성 제어를 직접 다루지 않습니다(락 충돌을 최소화하는 내부 노드 제어 기법은 **18.10.2절** 참조).  
> 또한 **리프 노드 잠금**은 실제로 프레디킷과 **충돌하지 않는 갱신**까지 막는 **과잉 잠금**을 유발할 수 있습니다. 이를 줄이기 위한 변형으로 **Key-Value Locking**이 있으며, **18.10.2절**에서 인덱스 동시성 제어의 일부로 소개됩니다.

---

## 대안: 프레디킷 잠금(Predicate Locking)

17.10절에서 언급했듯, 트랜잭션 간 충돌의 존재가 사용자 관점과 무관한 **낮은 수준의 질의 처리 결정**(예: 인덱스 사용 여부)에 좌우되는 문제를 줄이기 위한 대안이 **프레디킷 잠금**입니다.

- 질의의 **프레디킷**(예: `instructor`에서 `salary > 90000`)에 대해 **공유(S) 락**을 획득합니다.
- 이후 릴레이션의 **삽입/삭제**가 그 프레디킷을 **만족하는지 검사**하고, 만족하면 **락 충돌**로 보아 프레디킷 락이 해제될 때까지 **대기**시킵니다.
- **갱신**의 경우, 튜플의 **변경 전/후 값 모두**를 프레디킷에 대해 검사합니다.
- 이렇게 프레디킷을 만족하는 **삽입/삭제/갱신**은 해당 프레디킷 락을 획득한 **질의와 동시 실행될 수 없습니다.**

> 다만 **프레디킷 잠금은 실무에서 거의 사용되지 않습니다.**  
> 이유는 **구현 비용**이 크고, **인덱스 잠금 프로토콜**에 비해 **추가적 이점이 크지 않기 때문**입니다.
