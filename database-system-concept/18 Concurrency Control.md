# Concurrency Control (동시성 제어) — 요약 및 해설

> 17장에서 트랜잭션의 핵심 속성 중 하나가 **격리성(Isolation)** 이라고 했습니다. 하지만 여러 트랜잭션이 **동시에** 실행되면 격리성이 깨질 수 있습니다. 이를 방지하기 위해 시스템은 **동시성 제어(Concurrency-Control)** 기법으로 트랜잭션 간 상호작용을 관리합니다.  
> 이 문서는 실패 복구는 제외(19장에서 다룸)하고, **동시에 실행되는 트랜잭션의 관리**와 대표 기법들을 정리합니다. 실무에서 가장 널리 쓰이는 기법은 **2단계 잠금(2PL)** 과 **스냅샷 격리(Snapshot Isolation)** 입니다.

---

## 1) 잠금 기반 프로토콜 (Lock-Based Protocols)

### 1-1. 잠금 모드 (Locks)
데이터 항목 `Q`에 대해 트랜잭션 `Ti`가 요청/보유할 수 있는 대표 모드는 두 가지입니다.

- **S (Shared, 공유)**: 읽기 가능, 쓰기 불가  
- **X (Exclusive, 배타)**: 읽기/쓰기 모두 가능

여러 트랜잭션이 **동시에 읽기(S)** 는 허용되지만, **쓰기(X)** 는 **단독**이어야 합니다.

#### 잠금 호환성(Compatibility)
요청 모드 A, 보유 모드 B의 호환성은 아래와 같습니다.

|      | S     | X     |
|------|-------|-------|
| **S** | true  | false |
| **X** | false | false |

- **S-S** 는 호환(같이 읽기 OK)  
- **S-X**, **X-무엇이든** 은 비호환

#### 잠금/해제 명령
- `lock-S(Q)`: Q에 대한 공유 잠금 요청  
- `lock-X(Q)`: Q에 대한 배타 잠금 요청  
- `unlock(Q)`: Q 잠금 해제

> **주의**: 데이터 항목에 접근(읽기/쓰기)하는 동안에는 **항상** 해당 항목의 잠금을 **보유**해야 합니다. 마지막 접근 직후 곧바로 풀면 **직렬가능성**이 깨질 수 있습니다.

### 1-2. 예시: 은행 송금과 총액 출력

- `T1`: B에서 A로 \$50 이체  
- `T2`: A+B 총액 출력

초기값이 `A=100`, `B=200`이면, 직렬 실행(`T1→T2` 또는 `T2→T1`)은 항상 **300**을 출력합니다.  
하지만 동시 실행에서 `T1`이 **너무 일찍 B의 잠금을 해제**하면, `T2`가 **불일치 상태**를 읽어 **250**을 출력할 수 있습니다.

해결책: **해제 시점을 트랜잭션 끝(커밋)으로 지연**하면, 위와 같은 잘못된 스케줄은 더 이상 발생하지 않습니다(아래 Strict 2PL 참고).

### 1-3. 교착상태(Deadlock)
잠금을 **너무 늦게** 풀면 이번에는 **교착상태**가 발생할 수 있습니다.  
예: `T3`가 `B`에 X를 보유하는 동안 `T4`가 `B`의 S를 요청하여 대기하고, 동시에 `T4`가 `A`에 S를 보유하는 동안 `T3`가 `A`의 X를 요청하여 서로 **서로를 기다리는** 상황이 될 수 있습니다.  
이때 시스템은 **둘 중 하나를 롤백**하여 잠금을 풀고 진행시킵니다.

> **요점**:  
> - **잠금을 쓰지 않거나 너무 일찍 해제** ⇒ **불일치 상태** 위험  
> - **잠금을 너무 늦게 해제** ⇒ **교착** 위험  
> - 현실적으로 교착은 **롤백으로 해결 가능**하므로 감수할 수 있지만, 불일치 상태는 실제 문제를 초래하므로 **더 위험**합니다.

---

## 2) 스케줄·직렬가능성과 잠금 프로토콜

- 트랜잭션 집합 `{T0, …, Tn}`의 스케줄 `S`에서, 항목 `Q`에 대해 `Ti`가 먼저 모드 `A`로 잠그고, 이후 `Tj`가 모드 `B`로 잠갔으며 `comp(A,B)=false` 라면 `Ti → Tj` 라고 합니다.  
- 이 **선행관계 그래프**가 **비순환**이면 **충돌 직렬가능(Conflict-Serializable)** 입니다.  
- **잠금 프로토콜**은 “언제 무엇을 잠그고/푸는가”의 규칙으로, 가능한 스케줄을 제한하여 **충돌 직렬가능성**을 보장합니다.

---

## 3) 잠금 부여(Granting)와 기아(Starvation) 방지

요청이 기존 잠금과 **충돌하지 않으면** 즉시 부여할 수 있습니다. 다만 **기아**를 피하려면:

- 항목 `Q`에 대해 트랜잭션 `Ti`의 모드 `M` 요청은  
  1) 현재 `Q`에 **충돌 모드**가 없어야 하고,  
  2) `Ti`보다 **이전에 도착해 대기 중인 요청이 없어야**  
부여합니다. (**선착순 보장**)

---

## 4) 2단계 잠금 (Two-Phase Locking, 2PL)

**규칙**:
1. **성장 단계**: 잠금 **획득만** 가능 (해제 금지)  
2. **축소 단계**: 잠금 **해제만** 가능 (새 획득 금지)

- 각 트랜잭션의 **마지막 잠금 획득 시점**(Lock Point) 순서가 곧 직렬 순서가 되어 **충돌 직렬가능성**을 보장합니다.
- 단, **교착 회피는 보장하지 않음**.
- 기본 2PL은 **연쇄 롤백(Cascading Rollback)** 이 발생할 수 있습니다.

### 4-1. Strict / Rigorous 2PL

- **Strict 2PL**: **모든 X 잠금**을 **커밋까지 유지**  
  → 미커밋 쓰기 데이터를 타 트랜잭션이 읽지 못해 **연쇄 롤백 방지**

- **Rigorous 2PL**: **모든 잠금(S/X)** 을 **커밋까지 유지**  
  → **커밋 순서**가 곧 **직렬 순서**

### 4-2. 잠금 변환 (Lock Conversion)

동시성을 높이기 위해 **변환**을 허용할 수 있습니다.

- **업그레이드(Upgrade)**: `S → X` (**성장 단계에서만** 허용)  
- **다운그레이드(Downgrade)**: `X → S` (**축소 단계에서만** 허용)

> 예: 대부분 읽기만 하다가 마지막에만 쓰기 필요 시, 처음엔 `S`로 진행하다가 마지막에 `X`로 업그레이드하면 다른 트랜잭션과 **동시성**을 높일 수 있습니다.

### 4-3. 자동 잠금 부여 스키마(간이 구현)

- `read(Q)` 호출 시: `lock-S(Q)` → `read(Q)`  
- `write(Q)` 호출 시: 보유 잠금이 `S`면 `upgrade(Q)` 후 `write(Q)`, 아니면 `lock-X(Q)` 후 `write(Q)`  
- 트랜잭션 **커밋/어보트** 시 보유 잠금 **전부 해제**

---

## 5) 잠금 매니저 구현 (Lock Manager)

**구성요소**:
- **잠금 테이블**(Lock Table): 항목 이름을 키로 해당 항목의 **요청 대기열(연결 리스트)** 관리  
  - 각 요청: (트랜잭션 ID, 모드, 승인 여부)  
  - 항목별로 **도착 순서** 유지(선착순으로 기아 방지)  
- **트랜잭션 인덱스**: 특정 트랜잭션이 보유 중인 잠금 집합 조회용

**동작**:
- **요청 수신**: 리스트 뒤에 추가. 즉시 승인 가능하면 승인, 아니면 대기  
- **해제 수신**: 해당 요청 삭제 후 **다음 대기 요청들**을 순서대로 **승인 가능하면 승인**  
- **어보트**: 대기 요청 제거, 복구 완료 후 보유 잠금 해제

> 이 구조는 **기아 방지**를 보장합니다. (교착 검출/해결은 별도)

---

## 6) 그래프 기반 프로토콜 (Graph-Based Protocols)

2PL이 아닌 프로토콜로도 **충돌 직렬가능**을 만들려면 **추가 정보**(데이터 접근 순서)가 필요합니다.  
데이터 항목 집합 `D = {d1, …, dh}` 에 **부분 순서 `→`** 를 부여하여, `di → dj` 이면 둘 다 접근하는 트랜잭션은 **반드시 `di`를 먼저** 접근해야 한다고 강제합니다. 이렇게 하면 `D`는 DAG(데이터베이스 그래프)가 됩니다.

여기서는 단순화를 위해 **트리 형태**만 다루고, **배타(X) 잠금만** 쓰는 **트리 프로토콜(Tree Protocol)** 을 소개합니다.

### 트리 프로토콜 규칙 (트랜잭션 `Ti`)
1. `Ti`의 **첫 잠금**은 **임의 항목**에서 가능  
2. 이후 항목 `Q`를 잠그려면 **`Q`의 부모를 현재 `Ti`가 잠그고 있어야** 함  
3. **언제든** 잠금 해제 가능  
4. 한 번 **잠그고 해제한 항목**은 **다시 잠글 수 없음**

- 트리 프로토콜을 따르는 **모든 합법 스케줄은 충돌 직렬가능**입니다.
- 또한 **교착이 발생하지 않습니다(Deadlock-Free)**.

> 다만 트리 프로토콜은 기본 형태로는 **회복 가능성/비연쇄성**을 보장하지 않습니다. 이를 보장하려면 X 잠금을 **커밋까지 유지**하거나, **커밋 의존성**(미커밋 데이터 읽기 시, 해당 작성자 트랜잭션이 커밋될 때까지 독자 트랜잭션 커밋 금지)을 관리하는 방식을 사용할 수 있습니다.

### 장단점 요약
- **장점**: 교착 없음, 잠금을 더 **일찍 해제**할 수 있어 동시성 향상 가능  
- **단점**: 실제로 접근하지 않을 **경로상의 노드까지 잠가야** 할 수 있어 오버헤드/대기 증가, 사전 접근 경로 지식이 없으면 루트부터 잠가야 해서 동시성 저하

> 2PL로 가능한 어떤 스케줄은 트리 프로토콜로는 불가능하고, 그 **반대**도 존재합니다.

---

## 참고: 용어 정리

- **충돌 직렬가능(Conflict-Serializable)**: 충돌(비호환) 연산 순서를 보존하는 직렬 스케줄과 동등  
- **연쇄 롤백(Cascading Rollback)**: 미커밋 데이터를 읽은 트랜잭션들이 도미노처럼 되돌려지는 현상  
- **Strict 2PL**: 모든 **X 잠금**을 커밋까지 유지(연쇄 롤백 방지)  
- **Rigorous 2PL**: 모든 **S/X 잠금**을 커밋까지 유지(커밋 순서=직렬 순서)  
- **기아(Starvation)**: 어떤 요청이 계속 뒤로 밀려 영원히 처리되지 않는 상태  
- **교착(Deadlock)**: 서로가 서로의 자원을 기다려 아무도 진행하지 못하는 상태

---

## 빠른 요약(핵심만)

- **S/X 잠금**, 호환성 표로 충돌 판단  
- **2PL**: 성장 단계(획득만) → 축소 단계(해제만) ⇒ **충돌 직렬가능 보장**  
- **Strict/Rigorous 2PL**: **연쇄 롤백 방지**, **커밋 순서 직렬화**  
- **잠금 변환(업/다운그레이드)** 으로 동시성 향상  
- **잠금 매니저**: 항목별 대기열 + 선착순으로 **기아 방지**  
- **트리 프로토콜**: **교착 없음**, 경로 잠금 필요(오버헤드 가능)

---

# Deadlock Handling (교착상태 처리)

시스템이 **교착상태(deadlock)** 에 빠졌다는 것은, 어떤 트랜잭션 집합이 존재하여 그 집합에 속한 **모든 트랜잭션이 서로 집합 안의 다른 트랜잭션을 기다리고 있음**을 의미합니다.  
좀 더 정확히 말하면, **대기 중인 트랜잭션 집합** `{T0, T1, …, Tn}` 이 존재하여:

- `T0` 는 `T1` 이 보유한 데이터 항목을 기다리고,
- `T1` 은 `T2` 가 보유한 데이터 항목을 기다리고,
- …
- `Tn−1` 은 `Tn` 이 보유한 데이터 항목을 기다리며,
- `Tn` 은 `T0` 가 보유한 데이터 항목을 기다립니다.

이러한 상황에서는 어떤 트랜잭션도 **진행할 수 없습니다**.

---

## 교착상태 발생 시 조치

이 바람직하지 않은 상황을 해소하기 위해 시스템은 **급진적인 조치(drastic action)** 를 취해야 하며, 보통 **교착상태에 연루된 일부 트랜잭션을 롤백**합니다.

- **부분 롤백(Partial Rollback)**: 트랜잭션 전체를 되돌리는 대신, **교착 해소에 필요한 특정 락을 획득하기 전 지점**까지 되돌립니다. 해당 락을 **해제**함으로써 교착을 해소할 수 있습니다.

---

## 교착상태 대응 방법(두 가지 원칙)

1. **교착상태 예방(Deadlock Prevention)**
   - 시스템이 **교착상태에 절대 진입하지 않도록** 하는 프로토콜을 사용합니다.

2. **교착상태 탐지 및 복구(Deadlock Detection & Recovery)**
   - 교착상태에 **진입을 허용**한 뒤, **탐지 알고리즘**으로 교착을 발견하고 **복구 절차**(예: 롤백)로 해소합니다.

> 두 방법 모두 상황에 따라 **트랜잭션 롤백**이 발생할 수 있습니다.

---

## 선택 가이드

- 시스템이 **교착상태에 빠질 확률이 비교적 높다면** → **예방(Prevention)** 이 일반적으로 선호됩니다.
- 그 외의 경우 → **탐지 및 복구(Detection & Recovery)** 가 **더 효율적**인 경향이 있습니다.

---

## 탐지·복구 방식의 오버헤드

탐지 및 복구 방식은 다음과 같은 **추가 비용**을 수반합니다.

- **런타임 비용**: 필요한 정보를 유지하고 **탐지 알고리즘을 실행**하는 비용
- **잠재적 손실**: 교착상태에서 **복구(예: 롤백)** 과정에서 발생할 수 있는 **성능 저하 및 작업 손실**

---
