# Concurrency Control (동시성 제어) — 요약 및 해설

> 17장에서 트랜잭션의 핵심 속성 중 하나가 **격리성(Isolation)** 이라고 했습니다. 하지만 여러 트랜잭션이 **동시에** 실행되면 격리성이 깨질 수 있습니다. 이를 방지하기 위해 시스템은 **동시성 제어(Concurrency-Control)** 기법으로 트랜잭션 간 상호작용을 관리합니다.  
> 이 문서는 실패 복구는 제외(19장에서 다룸)하고, **동시에 실행되는 트랜잭션의 관리**와 대표 기법들을 정리합니다. 실무에서 가장 널리 쓰이는 기법은 **2단계 잠금(2PL)** 과 **스냅샷 격리(Snapshot Isolation)** 입니다.

---

## 1) 잠금 기반 프로토콜 (Lock-Based Protocols)

### 1-1. 잠금 모드 (Locks)
데이터 항목 `Q`에 대해 트랜잭션 `Ti`가 요청/보유할 수 있는 대표 모드는 두 가지입니다.

- **S (Shared, 공유)**: 읽기 가능, 쓰기 불가  
- **X (Exclusive, 배타)**: 읽기/쓰기 모두 가능

여러 트랜잭션이 **동시에 읽기(S)** 는 허용되지만, **쓰기(X)** 는 **단독**이어야 합니다.

#### 잠금 호환성(Compatibility)
요청 모드 A, 보유 모드 B의 호환성은 아래와 같습니다.

|      | S     | X     |
|------|-------|-------|
| **S** | true  | false |
| **X** | false | false |

- **S-S** 는 호환(같이 읽기 OK)  
- **S-X**, **X-무엇이든** 은 비호환

#### 잠금/해제 명령
- `lock-S(Q)`: Q에 대한 공유 잠금 요청  
- `lock-X(Q)`: Q에 대한 배타 잠금 요청  
- `unlock(Q)`: Q 잠금 해제

> **주의**: 데이터 항목에 접근(읽기/쓰기)하는 동안에는 **항상** 해당 항목의 잠금을 **보유**해야 합니다. 마지막 접근 직후 곧바로 풀면 **직렬가능성**이 깨질 수 있습니다.

### 1-2. 예시: 은행 송금과 총액 출력

- `T1`: B에서 A로 \$50 이체  
- `T2`: A+B 총액 출력

초기값이 `A=100`, `B=200`이면, 직렬 실행(`T1→T2` 또는 `T2→T1`)은 항상 **300**을 출력합니다.  
하지만 동시 실행에서 `T1`이 **너무 일찍 B의 잠금을 해제**하면, `T2`가 **불일치 상태**를 읽어 **250**을 출력할 수 있습니다.

해결책: **해제 시점을 트랜잭션 끝(커밋)으로 지연**하면, 위와 같은 잘못된 스케줄은 더 이상 발생하지 않습니다(아래 Strict 2PL 참고).

### 1-3. 교착상태(Deadlock)
잠금을 **너무 늦게** 풀면 이번에는 **교착상태**가 발생할 수 있습니다.  
예: `T3`가 `B`에 X를 보유하는 동안 `T4`가 `B`의 S를 요청하여 대기하고, 동시에 `T4`가 `A`에 S를 보유하는 동안 `T3`가 `A`의 X를 요청하여 서로 **서로를 기다리는** 상황이 될 수 있습니다.  
이때 시스템은 **둘 중 하나를 롤백**하여 잠금을 풀고 진행시킵니다.

> **요점**:  
> - **잠금을 쓰지 않거나 너무 일찍 해제** ⇒ **불일치 상태** 위험  
> - **잠금을 너무 늦게 해제** ⇒ **교착** 위험  
> - 현실적으로 교착은 **롤백으로 해결 가능**하므로 감수할 수 있지만, 불일치 상태는 실제 문제를 초래하므로 **더 위험**합니다.

---

## 2) 스케줄·직렬가능성과 잠금 프로토콜

- 트랜잭션 집합 `{T0, …, Tn}`의 스케줄 `S`에서, 항목 `Q`에 대해 `Ti`가 먼저 모드 `A`로 잠그고, 이후 `Tj`가 모드 `B`로 잠갔으며 `comp(A,B)=false` 라면 `Ti → Tj` 라고 합니다.  
- 이 **선행관계 그래프**가 **비순환**이면 **충돌 직렬가능(Conflict-Serializable)** 입니다.  
- **잠금 프로토콜**은 “언제 무엇을 잠그고/푸는가”의 규칙으로, 가능한 스케줄을 제한하여 **충돌 직렬가능성**을 보장합니다.

---

## 3) 잠금 부여(Granting)와 기아(Starvation) 방지

요청이 기존 잠금과 **충돌하지 않으면** 즉시 부여할 수 있습니다. 다만 **기아**를 피하려면:

- 항목 `Q`에 대해 트랜잭션 `Ti`의 모드 `M` 요청은  
  1) 현재 `Q`에 **충돌 모드**가 없어야 하고,  
  2) `Ti`보다 **이전에 도착해 대기 중인 요청이 없어야**  
부여합니다. (**선착순 보장**)

---

## 4) 2단계 잠금 (Two-Phase Locking, 2PL)

**규칙**:
1. **성장 단계**: 잠금 **획득만** 가능 (해제 금지)  
2. **축소 단계**: 잠금 **해제만** 가능 (새 획득 금지)

- 각 트랜잭션의 **마지막 잠금 획득 시점**(Lock Point) 순서가 곧 직렬 순서가 되어 **충돌 직렬가능성**을 보장합니다.
- 단, **교착 회피는 보장하지 않음**.
- 기본 2PL은 **연쇄 롤백(Cascading Rollback)** 이 발생할 수 있습니다.

### 4-1. Strict / Rigorous 2PL

- **Strict 2PL**: **모든 X 잠금**을 **커밋까지 유지**  
  → 미커밋 쓰기 데이터를 타 트랜잭션이 읽지 못해 **연쇄 롤백 방지**

- **Rigorous 2PL**: **모든 잠금(S/X)** 을 **커밋까지 유지**  
  → **커밋 순서**가 곧 **직렬 순서**

### 4-2. 잠금 변환 (Lock Conversion)

동시성을 높이기 위해 **변환**을 허용할 수 있습니다.

- **업그레이드(Upgrade)**: `S → X` (**성장 단계에서만** 허용)  
- **다운그레이드(Downgrade)**: `X → S` (**축소 단계에서만** 허용)

> 예: 대부분 읽기만 하다가 마지막에만 쓰기 필요 시, 처음엔 `S`로 진행하다가 마지막에 `X`로 업그레이드하면 다른 트랜잭션과 **동시성**을 높일 수 있습니다.

### 4-3. 자동 잠금 부여 스키마(간이 구현)

- `read(Q)` 호출 시: `lock-S(Q)` → `read(Q)`  
- `write(Q)` 호출 시: 보유 잠금이 `S`면 `upgrade(Q)` 후 `write(Q)`, 아니면 `lock-X(Q)` 후 `write(Q)`  
- 트랜잭션 **커밋/어보트** 시 보유 잠금 **전부 해제**

---

## 5) 잠금 매니저 구현 (Lock Manager)

**구성요소**:
- **잠금 테이블**(Lock Table): 항목 이름을 키로 해당 항목의 **요청 대기열(연결 리스트)** 관리  
  - 각 요청: (트랜잭션 ID, 모드, 승인 여부)  
  - 항목별로 **도착 순서** 유지(선착순으로 기아 방지)  
- **트랜잭션 인덱스**: 특정 트랜잭션이 보유 중인 잠금 집합 조회용

**동작**:
- **요청 수신**: 리스트 뒤에 추가. 즉시 승인 가능하면 승인, 아니면 대기  
- **해제 수신**: 해당 요청 삭제 후 **다음 대기 요청들**을 순서대로 **승인 가능하면 승인**  
- **어보트**: 대기 요청 제거, 복구 완료 후 보유 잠금 해제

> 이 구조는 **기아 방지**를 보장합니다. (교착 검출/해결은 별도)

---

## 6) 그래프 기반 프로토콜 (Graph-Based Protocols)

2PL이 아닌 프로토콜로도 **충돌 직렬가능**을 만들려면 **추가 정보**(데이터 접근 순서)가 필요합니다.  
데이터 항목 집합 `D = {d1, …, dh}` 에 **부분 순서 `→`** 를 부여하여, `di → dj` 이면 둘 다 접근하는 트랜잭션은 **반드시 `di`를 먼저** 접근해야 한다고 강제합니다. 이렇게 하면 `D`는 DAG(데이터베이스 그래프)가 됩니다.

여기서는 단순화를 위해 **트리 형태**만 다루고, **배타(X) 잠금만** 쓰는 **트리 프로토콜(Tree Protocol)** 을 소개합니다.

### 트리 프로토콜 규칙 (트랜잭션 `Ti`)
1. `Ti`의 **첫 잠금**은 **임의 항목**에서 가능  
2. 이후 항목 `Q`를 잠그려면 **`Q`의 부모를 현재 `Ti`가 잠그고 있어야** 함  
3. **언제든** 잠금 해제 가능  
4. 한 번 **잠그고 해제한 항목**은 **다시 잠글 수 없음**

- 트리 프로토콜을 따르는 **모든 합법 스케줄은 충돌 직렬가능**입니다.
- 또한 **교착이 발생하지 않습니다(Deadlock-Free)**.

> 다만 트리 프로토콜은 기본 형태로는 **회복 가능성/비연쇄성**을 보장하지 않습니다. 이를 보장하려면 X 잠금을 **커밋까지 유지**하거나, **커밋 의존성**(미커밋 데이터 읽기 시, 해당 작성자 트랜잭션이 커밋될 때까지 독자 트랜잭션 커밋 금지)을 관리하는 방식을 사용할 수 있습니다.

### 장단점 요약
- **장점**: 교착 없음, 잠금을 더 **일찍 해제**할 수 있어 동시성 향상 가능  
- **단점**: 실제로 접근하지 않을 **경로상의 노드까지 잠가야** 할 수 있어 오버헤드/대기 증가, 사전 접근 경로 지식이 없으면 루트부터 잠가야 해서 동시성 저하

> 2PL로 가능한 어떤 스케줄은 트리 프로토콜로는 불가능하고, 그 **반대**도 존재합니다.

---

## 참고: 용어 정리

- **충돌 직렬가능(Conflict-Serializable)**: 충돌(비호환) 연산 순서를 보존하는 직렬 스케줄과 동등  
- **연쇄 롤백(Cascading Rollback)**: 미커밋 데이터를 읽은 트랜잭션들이 도미노처럼 되돌려지는 현상  
- **Strict 2PL**: 모든 **X 잠금**을 커밋까지 유지(연쇄 롤백 방지)  
- **Rigorous 2PL**: 모든 **S/X 잠금**을 커밋까지 유지(커밋 순서=직렬 순서)  
- **기아(Starvation)**: 어떤 요청이 계속 뒤로 밀려 영원히 처리되지 않는 상태  
- **교착(Deadlock)**: 서로가 서로의 자원을 기다려 아무도 진행하지 못하는 상태

---

## 빠른 요약(핵심만)

- **S/X 잠금**, 호환성 표로 충돌 판단  
- **2PL**: 성장 단계(획득만) → 축소 단계(해제만) ⇒ **충돌 직렬가능 보장**  
- **Strict/Rigorous 2PL**: **연쇄 롤백 방지**, **커밋 순서 직렬화**  
- **잠금 변환(업/다운그레이드)** 으로 동시성 향상  
- **잠금 매니저**: 항목별 대기열 + 선착순으로 **기아 방지**  
- **트리 프로토콜**: **교착 없음**, 경로 잠금 필요(오버헤드 가능)

---

# Deadlock Handling (교착상태 처리)

시스템이 **교착상태(deadlock)** 에 빠졌다는 것은, 어떤 트랜잭션 집합이 존재하여 그 집합에 속한 **모든 트랜잭션이 서로 집합 안의 다른 트랜잭션을 기다리고 있음**을 의미합니다.  
좀 더 정확히 말하면, **대기 중인 트랜잭션 집합** `{T0, T1, …, Tn}` 이 존재하여:

- `T0` 는 `T1` 이 보유한 데이터 항목을 기다리고,
- `T1` 은 `T2` 가 보유한 데이터 항목을 기다리고,
- …
- `Tn−1` 은 `Tn` 이 보유한 데이터 항목을 기다리며,
- `Tn` 은 `T0` 가 보유한 데이터 항목을 기다립니다.

이러한 상황에서는 어떤 트랜잭션도 **진행할 수 없습니다**.

---

## 교착상태 발생 시 조치

이 바람직하지 않은 상황을 해소하기 위해 시스템은 **급진적인 조치(drastic action)** 를 취해야 하며, 보통 **교착상태에 연루된 일부 트랜잭션을 롤백**합니다.

- **부분 롤백(Partial Rollback)**: 트랜잭션 전체를 되돌리는 대신, **교착 해소에 필요한 특정 락을 획득하기 전 지점**까지 되돌립니다. 해당 락을 **해제**함으로써 교착을 해소할 수 있습니다.

---

## 교착상태 대응 방법(두 가지 원칙)

1. **교착상태 예방(Deadlock Prevention)**
   - 시스템이 **교착상태에 절대 진입하지 않도록** 하는 프로토콜을 사용합니다.

2. **교착상태 탐지 및 복구(Deadlock Detection & Recovery)**
   - 교착상태에 **진입을 허용**한 뒤, **탐지 알고리즘**으로 교착을 발견하고 **복구 절차**(예: 롤백)로 해소합니다.

> 두 방법 모두 상황에 따라 **트랜잭션 롤백**이 발생할 수 있습니다.

---

## 선택 가이드

- 시스템이 **교착상태에 빠질 확률이 비교적 높다면** → **예방(Prevention)** 이 일반적으로 선호됩니다.
- 그 외의 경우 → **탐지 및 복구(Detection & Recovery)** 가 **더 효율적**인 경향이 있습니다.

---

## 탐지·복구 방식의 오버헤드

탐지 및 복구 방식은 다음과 같은 **추가 비용**을 수반합니다.

- **런타임 비용**: 필요한 정보를 유지하고 **탐지 알고리즘을 실행**하는 비용
- **잠재적 손실**: 교착상태에서 **복구(예: 롤백)** 과정에서 발생할 수 있는 **성능 저하 및 작업 손실**

---

# 18.2.1 Deadlock Prevention (교착상태 예방)

교착상태 예방에는 **두 가지 접근**이 있습니다.

1) **순환 대기(cyclic wait) 자체를 불가능하게** 만드는 방식  
   - 락 요청에 **순서(ordering)** 를 부여하거나, **모든 락을 한꺼번에** 획득하도록 강제

2) **잠재적 교착 상황에서 기다리지 않고 즉시 롤백**하는 방식  
   - 교착이 **될 수도 있는 대기**라면 **기다림 대신 롤백**을 수행

---

## 1. “순환 대기 불가” 방식

### 1.1 모든 데이터 항목을 실행 전 **일괄 락**(all-or-nothing)
- 각 트랜잭션이 **시작 전에 필요 데이터 전부를 락**으로 잡고,  
  **전부를 한 번에** 잠그거나 **아예 하나도 잠그지 않음**.
- **단점**
  1. 트랜잭션 시작 전에 **무슨 항목을 락해야 하는지 예측**하기 어렵다.
  2. **자원 활용도 저하**: 오래 쓰지 않을 항목까지 **오랫동안 불필요하게 락**.

### 1.2 데이터 항목에 **순서(order)** 를 부여해 **그 순서대로만 락** 요청
- 예: **트리 프로토콜(Tree Protocol)** — 데이터 항목에 **부분 순서(partial order)** 부여
- 변형: **총순서(total order)** + **2단계 잠금(2PL)**  
  - 한 항목을 락으로 잡은 뒤에는, **그보다 앞서는 항목**에 대해 **새로운 락을 요청할 수 없음**.
  - 구현이 간단(트랜잭션이 접근할 항목 집합이 **사전에 알려진 경우**).
  - **기존 2PL 엔진을 바꾸지 않고**, **락 요청 순서만 보장**하면 됨.

---

## 2. “대기 대신 롤백” 방식 (선점/타임스탬프 기반)

**선점(preemption)**: `Tj`가 `Ti`가 보유한 락을 요청했을 때,  
`Ti`를 **롤백**시켜 락을 **Tj**에게 주는 것.

- 각 트랜잭션 시작 시 **고유 타임스탬프**(카운터/시계 기반)를 부여
- 이 타임스탬프는 **기다릴지 롤백할지** 결정을 위해서만 사용(락은 여전히 사용)
- **롤백 후 재시작**할 때는 **기존 타임스탬프 유지**

타임스탬프를 이용한 대표 **교착 예방** 기법 두 가지:

### 2.1 **Wait–Die** (비선점적, Nonpreemptive)
- `Ti`가 `Tj`가 보유한 항목을 요청할 때,
  - `TS(Ti) < TS(Tj)` (즉, **Ti가 더 오래됨**) 이면 **기다릴 수 있음**.
  - 그렇지 않으면 **Ti가 롤백(Die)**.
- 예: `T14(5), T15(10), T16(15)`  
  - `T14` → `T15`의 항목 요청 ⇒ **T14 기다림**  
  - `T16` → `T15`의 항목 요청 ⇒ **T16 롤백**

### 2.2 **Wound–Wait** (선점적, Preemptive)
- `Ti`가 `Tj`가 보유한 항목을 요청할 때,
  - `TS(Ti) < TS(Tj)` (즉, **Ti가 더 오래됨**) 이면 **Tj를 롤백**(Ti가 **상처(wound)** 를 입힘).  
  - 그렇지 않으면 **Ti가 기다림**.
- 예: `T14(5), T15(10), T16(15)`  
  - `T14` → `T15`의 항목 요청 ⇒ **T15 롤백**(선점)  
  - `T16` → `T15`의 항목 요청 ⇒ **T16 기다림**

> 두 방식 모두 **불필요한 롤백**이 발생할 수 있다는 **단점**이 있음.

---

## 3. **락 타임아웃 기반** 예방

- 락을 요청한 트랜잭션이 **최대 대기 시간**까지만 기다림.
- 그 시간 내 락을 못 얻으면 **타임아웃**으로 **자기 자신을 롤백 후 재시작**.
- 실제로 교착이 있었다면, 관련 트랜잭션 중 하나 이상이 타임아웃으로 **롤백되어** 다른 트랜잭션이 진행 가능.
- 성격: **완전한 예방**(교착이 절대 발생하지 않음)과 **탐지·복구**(발생 후 처리)의 **중간 어딘가**.
- **장점**: 구현이 **매우 간단**, **짧은 트랜잭션** & **오랜 대기=교착일 가능성 높음**인 환경에서 효과적.
- **어려움/주의**
  - **얼마나 기다려야 하는가**를 정하기 어려움.
    - 너무 길면: 교착 발생 후에도 **불필요한 지연**.
    - 너무 짧으면: **교착이 아닌데도 롤백**(자원 낭비).
  - **기아(Starvation)** 가능성.
  - 따라서 **적용 범위가 제한적**.

---

## 요약

- **순환 대기 차단**: 일괄 락, **(부분/총)순서 부여 + 2PL**  
- **대기 대신 롤백**: **Wait–Die / Wound–Wait** (타임스탬프 기반)  
- **타임아웃**: 간단하지만 **튜닝 난이도/기아 위험** → 환경에 따라 제한적  
- 모든 방법은 **성능·불필요 롤백·개발/운영 복잡도** 사이에서 **트레이드오프**가 있음.

---

# 18.2.2 Deadlock Detection and Recovery (교착상태 탐지와 복구)

교착상태가 절대 발생하지 않도록 보장하는 프로토콜을 사용하지 않는 시스템이라면, **탐지와 복구** 체계를 사용해야 합니다. 시스템 상태를 주기적으로 점검하여 **교착이 발생했는지** 확인하는 **탐지 알고리즘**을 호출합니다. 교착이 발견되면 **복구**를 시도해야 합니다. 이를 위해 시스템은 다음을 수행해야 합니다.

- 현재 **데이터 항목의 할당 정보**와 **대기 중인(미충족) 요청 정보**를 유지한다.
- 이 정보를 사용해 **교착 상태 진입 여부를 판정**하는 알고리즘을 제공한다.
- 탐지 알고리즘이 교착을 발견하면 **교착을 해소**(복구)한다.

아래에서 세부 사항을 설명합니다.

---

## 18.2.2.1 Deadlock Detection (교착상태 탐지)

교착상태는 **Wait-For Graph(대기 그래프)** 라는 방향 그래프로 정확히 표현할 수 있습니다.  
그래프는 쌍 \( G = (V, E) \) 로, \( V \) 는 정점 집합(시스템의 모든 트랜잭션), \( E \) 는 간선 집합입니다.  
각 간선은 **정렬쌍** \( T_i \rightarrow T_j \) 로 표시되며, 이는 **트랜잭션 \(T_i\) 가 \(T_j\)** 가 보유한 **필요 데이터 항목의 해제**를 기다리고 있음을 의미합니다.

- \(T_i\) 가 \(T_j\) 가 쥐고 있는 데이터 항목을 요청하면 **간선 \(T_i \rightarrow T_j\)** 를 그래프에 **삽입**합니다.
- \(T_j\) 가 더 이상 \(T_i\) 가 필요로 하는 항목을 보유하지 않게 되면 해당 **간선을 제거**합니다.
- **교착상태가 존재할 필요충분조건**: **대기 그래프에 사이클이 존재**한다.
- 탐지를 위해 시스템은 **대기 그래프를 유지**하고, **주기적으로 사이클 탐색** 알고리즘을 실행합니다.

### 예시 (그림 18.13)
- \(T_{17}\) 은 \(T_{18}\), \(T_{19}\) 를 기다림
- \(T_{19}\) 는 \(T_{18}\) 을 기다림
- \(T_{18}\) 은 \(T_{20}\) 을 기다림

이때 **사이클이 없으므로 교착상태가 아님**.

이후 \(T_{20}\) 이 \(T_{19}\) 가 보유한 항목을 요청하면 간선 \(T_{20} \rightarrow T_{19}\) 가 추가되어 **그림 18.14** 와 같은 상태가 되고, 다음 **사이클**이 생깁니다:

\[
T_{18} \rightarrow T_{20} \rightarrow T_{19} \rightarrow T_{18}
\]

따라서 \(T_{18}, T_{19}, T_{20}\) 은 **모두 교착** 상태입니다.

### 탐지 알고리즘을 언제 호출할 것인가?
다음 요소에 따라 결정합니다.

1. **교착 발생 빈도**가 얼마나 높은가?
2. 교착으로 인해 **영향을 받는 트랜잭션 수**가 얼마나 되는가?

- 교착이 **자주 발생**한다면, 탐지 알고리즘을 **더 자주 호출**해야 합니다.
- 교착에 묶인 데이터 항목은 **교착이 해소될 때까지** 다른 트랜잭션이 사용할 수 없습니다.
- 대기 그래프의 **사이클 수가 증가**할 수 있으므로, **최악의 경우**에는 **할당 요청이 즉시 처리되지 못할 때마다** 탐지 알고리즘을 호출할 수도 있습니다.

---

## 18.2.2.2 Recovery from Deadlock (교착상태 복구)

탐지 알고리즘이 교착을 발견하면, 시스템은 **교착을 해소**해야 합니다. 가장 일반적인 방법은 **하나 이상의 트랜잭션을 롤백**하여 사이클을 **끊는 것**입니다. 필요한 조치는 다음과 같습니다.

### 1) 희생자(victim) 선택
- 교착에 연루된 트랜잭션 중 **어느 것을 롤백할지** 결정합니다.
- 이상적으로는 **비용이 최소**가 되도록 선택해야 하나, **“최소 비용”의 정의는 모호**할 수 있습니다.
- **비용 판단 요소 예시**:
  - (a) 트랜잭션이 이미 **얼마나 오래 수행**했으며, 완료까지 **얼마나 더** 수행해야 하는가
  - (b) 트랜잭션이 **사용한 데이터 항목 수**
  - (c) 트랜잭션이 **추가로 필요**로 하는 데이터 항목 수
  - (d) 롤백에 **연루될 트랜잭션 수**

### 2) 롤백(rollback)
- 특정 트랜잭션을 롤백하기로 했다면, **어느 지점까지** 롤백할지 결정해야 합니다.
- 가장 단순한 방법은 **총 롤백(total rollback)**: **Abort 후 재시작**.
- 더 효과적인 방법은 **교착을 깨는 데 필요한 최소 지점까지만 부분 롤백**하는 것입니다.
  - 이를 위해 시스템은 실행 중인 모든 트랜잭션에 대한 **추가 상태 정보**를 유지해야 합니다.
  - 특히, **락 요청/부여의 순서**와 **수행된 갱신**을 기록해야 합니다.
  - **교착 탐지 메커니즘**은 **어떤 락을 해제**해야 교착이 깨지는지 결정해야 합니다.
  - 선택된 트랜잭션은 이 **락들을 최초로 획득한 시점까지 되돌아가고**, 그 이후의 모든 작업을 **되돌려야** 합니다.
  - 복구 메커니즘은 이러한 **부분 롤백**을 수행할 수 있어야 하며, 롤백 후 트랜잭션은 **다시 실행 재개**가 가능해야 합니다.

### 3) 기아(starvation) 방지
- 비용 위주로 희생자를 고르면 **같은 트랜잭션이 반복해서 희생**되는 일이 생길 수 있습니다.
- 이 경우 해당 트랜잭션은 **영원히 완료되지 못하는 기아**가 발생합니다.
- 대책: **롤백 횟수**를 비용 요소에 포함하는 등, **동일 트랜잭션이 희생자로 선택되는 횟수에 제한**을 둡니다.

---
